---
layout: blog
comments: true
tags: programming C++
title: C++使用笔记
---

## `operator<<`的重定义问题
C++中，一般将函数的定义放在.cpp文件中，而将函数的声明放在.h文件中。但是对于定义的`operator<<`函数则会存在问题，编译时会提示`multiple definition`。即使在头文件中只写了一个函数声明，也会有这样的错误。解决的方案是在声明或定义之前加上`inline`关键字，然后，无论你把定义放在头文件中，还是声明与定义分开，都不会有这个错误了。

还有一种方案是在头文件的类定义中使用`friend`声明，然后，在源文件中再定义`operator<<`。

## 子类中调用父类的方法
{% highlight cpp %}
SubClass a;
a.SupClass::method();
{% endhighlight %}
在子类的方法中，直接调用`SupClass::method()`即可。

## 模板函数中调用其它函数
当模板函数内调用其它函数`foo()`时，需要在模板函数定义之前和调用(实例化)之前都要声明此函数。否则编译会报错`there are no arguments to foo that depend on a template parameter`。这其实和一般函数是类似的，只不过报的错误有些怪异而已。


## 重载函数的多态
如果父类中有两个重载方法，如果在子类中一个多态继承了，另外一个没有，则子类只能直接访问到继承的那个virtual方法。比如下面的例子，父类和子类都实现了序列化的代码，但是真正的代码的接口是std::ostream，std::string的接口对于每个类都是一样的，因此不愿意重复实现。可惜的是，这一点是做不到的。如果你不在Child类中实现serialize(const std::string&)方法，它根本就无法直接访问到Parent类中的该方法，只能显式地调用Parent::serialize方法。
{% highlight cpp %}
#include <iostream>
#include <fstream>
#include <string>
class Parent {
	public:
		virtual void serialize(std::ostream& os) const {
			os << "Parent" << std::endl;
		}
		virtual void serialize(const std::string& filename) const {
			std::ofstream ofs(filename.c_str());
			serialize(ofs);
		}
};
class Child : public Parent {
	public:
		void serialize(std::ostream& os) const {
			os << "Child" << std::endl;
		}
		// you'd better implement this
		void serialize(const std::string& filename) const {
			Parent::serialize(filename);
		}
};
int main(int argc, char* argv[]){ 
	Child c;
	// method in Child, not Parent
	c.serialize("out.txt");
	// ugly way
	c.Parent::serialize("out.txt"); 
	return 0;
}
{% endhighlight %}

